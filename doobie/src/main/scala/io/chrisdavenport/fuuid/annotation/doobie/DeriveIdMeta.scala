package io.chrisdavenport.fuuid.annotation.doobie

import scala.annotation.{compileTimeOnly, StaticAnnotation}
import scala.reflect.macros.whitebox

/**
 * This annotation can be used on objects annotated with `DeriveId`
 * to automatically derive an implicit
 * [[https://git.io/fj64d doobie's Meta]]
 * instance for the generated `Id` type (an implicit `Meta[FUUID`
 * will be required, it can be provided via `fuuid-doobie`).
 *
 * @example For an object named `User` {{{
 * @DeriveId @DeriveIdMeta
 * object User {
 *
 *    //Methods, types and objects generated by `DeriveId`
 *    ...
 *
 *    implicit val IdMetaInstance: Meta[User.Id] = ???
 *
 * }
 * }}}
 */
@compileTimeOnly("enable macro paradise to expand macro annotations")
class DeriveIdMeta extends StaticAnnotation {
  def macroTransform(annottees: Any*): Any = macro DeriveIdMetaMacros.impl
}

object DeriveIdMetaMacros {

  @SuppressWarnings(
    Array(
      "org.wartremover.warts.Any",
      "org.wartremover.warts.Nothing",
      "org.wartremover.warts.PublicInference"
    ))
  def impl(c: whitebox.Context)(annottees: c.Expr[Any]*): c.Expr[Any] = {
    import c.universe._

    val (mods, name, parents, body) = (annottees map (_.tree)).headOption collect {
      case q"$mods object $name extends ..$parents { ..$body }" => (mods, name, parents, body)
    } getOrElse c.abort(c.enclosingPosition, "@DeriveIdMeta can only be used with objects")

    c.Expr[Any](q"""
      $mods object $name extends ..$parents {

        @SuppressWarnings(Array(
          "org.wartremover.warts.PublicInference",
          "org.wartremover.warts.ExplicitImplicitTypes"
        ))
        implicit val IdMetaInstance: _root_.doobie.util.Meta[$name.Id] =
          implicitly[_root_.doobie.util.Meta[_root_.io.chrisdavenport.fuuid.FUUID]]
            .timap($name.Id.apply)(identity)
        
        ..$body
      }
    """)
  }
}
